name: ðŸš€ Terraform Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment (stg/prd)'
        required: true
        default: 'stg'
        type: choice
        options:
          - stg
          - prd
      action:
        description: 'Action (plan/apply)'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
      recreate_ec2:
        description: 'Recreate EC2 instances (apply user_data changes)'
        required: false
        default: false
        type: boolean
      include_db_checks:
        description: 'After apply: gather RDS & secret status summary'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0

concurrency:
  group: terraform-${{ github.ref }}-${{ inputs.environment }}
  cancel-in-progress: true

jobs:
  terraform:
    name: TF ${{ inputs.action }} - ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: ðŸ”‘ AWS Credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ“¦ Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: ðŸ” Terraform Init
        run: terraform init
        working-directory: terraform/${{ inputs.environment }}

      - name: ðŸ“‹ Terraform Validate
        run: terraform validate
        working-directory: terraform/${{ inputs.environment }}

      - name: ðŸ”„ Taint EC2 instances (if recreate requested)
        if: inputs.recreate_ec2 == true
        run: |
          echo "Marking EC2 instances for recreation..."
          terraform state list | grep 'module.infrastructure.aws_instance.web' | while read resource; do
            terraform taint "$resource" || echo "Resource $resource already tainted or doesn't exist"
          done
        working-directory: terraform/${{ inputs.environment }}

      - name: ðŸ“Š Terraform Plan
        run: terraform plan -out=tfplan -no-color
        working-directory: terraform/${{ inputs.environment }}

      - name: ðŸ“ Show Plan
        run: terraform show tfplan
        working-directory: terraform/${{ inputs.environment }}

      - name: âœ… Terraform Apply
        if: inputs.action == 'apply'
        run: terraform apply -auto-approve tfplan
        working-directory: terraform/${{ inputs.environment }}

      - name: ðŸ“¤ Show Outputs
        if: inputs.action == 'apply'
        run: terraform output
        working-directory: terraform/${{ inputs.environment }}

      - name: ðŸ”‘ Export EC2 SSH Key to Secrets Manager
        if: inputs.action == 'apply' && inputs.recreate_ec2 == true
        env:
          ENV: ${{ inputs.environment }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          KEY_NAME="tx01-deploy-key"
          SECRET_NAME="tx01-ec2-ssh-key-${ENV}"
          
          echo "Checking if EC2 key pair exists..."
          if aws ec2 describe-key-pairs --key-names "$KEY_NAME" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "Key pair $KEY_NAME exists in AWS EC2"
            
            # Check if we have the private key locally (from previous creation)
            if [ -f "/tmp/${KEY_NAME}.pem" ]; then
              echo "Found local private key, storing in Secrets Manager..."
              aws secretsmanager create-secret \
                --name "$SECRET_NAME" \
                --description "EC2 SSH private key for ${ENV}" \
                --secret-string file:///tmp/${KEY_NAME}.pem \
                --region "$AWS_REGION" 2>/dev/null || \
              aws secretsmanager update-secret \
                --secret-id "$SECRET_NAME" \
                --secret-string file:///tmp/${KEY_NAME}.pem \
                --region "$AWS_REGION"
              echo "âœ… SSH key stored in Secrets Manager: $SECRET_NAME"
              rm -f /tmp/${KEY_NAME}.pem
            else
              echo "âš ï¸ Private key not found locally. Key pair exists but private key must be retrieved manually or recreated."
            fi
          else
            echo "Key pair doesn't exist, will be created by Terraform on next apply."
          fi

      - name: ðŸ—„ï¸ RDS Status & Secret (Post-Deploy)
        if: inputs.action == 'apply' && inputs.include_db_checks == true
        env:
          ENV: ${{ inputs.environment }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          echo "Collecting RDS & Secrets status..."
          DB_ID="tx01-db-${ENV}"
          # RDS status & endpoint (endpoint only appears when available)
          aws rds describe-db-instances \
            --db-instance-identifier "$DB_ID" \
            --query 'DBInstances[0].{Status:DBInstanceStatus,Endpoint:Endpoint.Address,Engine:Engine,Class:DBInstanceClass,MultiAZ:MultiAZ}' \
            --output table || echo "RDS instance not found yet"

          # Secret ARN from terraform output (non-sensitive) if present
          if terraform output -json | jq -e '.db_secret_arn' >/dev/null 2>&1; then
            SECRET_ARN=$(terraform output -raw db_secret_arn 2>/dev/null || true)
            if [ -n "$SECRET_ARN" ]; then
              echo "Secret ARN: $SECRET_ARN"
              aws secretsmanager describe-secret --secret-id "$SECRET_ARN" --query '{Name:Name,RotationEnabled:RotationEnabled,CreatedDate:CreatedDate}' --output table || true
            else
              echo "Secret ARN output not available (possibly not applied yet)."
            fi
          else
            echo "Terraform output 'db_secret_arn' not defined or unavailable."
          fi

          # Compose summary
          {
            echo "## ðŸ—„ï¸ RDS Post-Deploy (${ENV})";
            echo "";
            echo "**Instance ID:** $DB_ID";
            DB_STATUS=$(aws rds describe-db-instances --db-instance-identifier "$DB_ID" --query 'DBInstances[0].DBInstanceStatus' --output text 2>/dev/null || echo "unknown")
            echo "**Status:** $DB_STATUS";
            DB_ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier "$DB_ID" --query 'DBInstances[0].Endpoint.Address' --output text 2>/dev/null || echo "pending")
            echo "**Endpoint:** $DB_ENDPOINT";
            echo "**Engine/Class:** $(aws rds describe-db-instances --db-instance-identifier "$DB_ID" --query 'DBInstances[0].[Engine,DBInstanceClass]' --output text 2>/dev/null || echo "n/a")";
            echo "";
            if [ -n "$SECRET_ARN" ]; then
              echo "**Secret:** $SECRET_ARN";
            fi
            echo "**Notes:** Endpoint may be 'pending' for several minutes after creation.";
          } >> $GITHUB_STEP_SUMMARY

      - name: ðŸ” Wait for RDS Available (Optional Fast Check)
        if: inputs.action == 'apply' && inputs.include_db_checks == true
        env:
          ENV: ${{ inputs.environment }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          DB_ID="tx01-db-${ENV}"
          echo "Waiting up to 8 minutes for RDS to become 'available'..."
          END_TIME=$(( $(date +%s) + 480 ))
          while [ $(date +%s) -lt $END_TIME ]; do
            STATUS=$(aws rds describe-db-instances --db-instance-identifier "$DB_ID" --query 'DBInstances[0].DBInstanceStatus' --output text 2>/dev/null || echo "not-found")
            echo "Current status: $STATUS"
            if [ "$STATUS" = "available" ]; then
              echo "RDS is available."; break; fi
            sleep 20
          done
          FINAL_STATUS=$(aws rds describe-db-instances --db-instance-identifier "$DB_ID" --query 'DBInstances[0].DBInstanceStatus' --output text 2>/dev/null || echo "not-found")
          {
            echo "## â±ï¸ Final RDS Status";
            echo "Status: $FINAL_STATUS";
            echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)";
          } >> $GITHUB_STEP_SUMMARY

      - name: ðŸŒ App Health Check (Post-Deploy)
        if: inputs.action == 'apply' && inputs.include_db_checks == true
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          cd terraform/${{ inputs.environment }}
          ALB=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
          if [ -z "$ALB" ]; then
            echo "ALB DNS output not found"; exit 0; fi
          echo "Checking app health at http://$ALB/api/health ..."
          RESP=$(curl -s --max-time 10 "http://$ALB/api/health" || echo "")
          echo "Response: $RESP"
          DB_CONNECTED=$(echo "$RESP" | jq -r '.database.connected' 2>/dev/null || echo "unknown")
          {
            echo "## ðŸŒ App Health";
            echo "URL: http://$ALB/api/health";
            echo "database.connected: $DB_CONNECTED";
          } >> $GITHUB_STEP_SUMMARY
