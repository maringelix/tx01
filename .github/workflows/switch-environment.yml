name: üîÑ Switch Environment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - stg
          - prd
        default: 'stg'
      mode:
        description: 'Compute mode'
        required: true
        type: choice
        options:
          - ec2
          - eks
          - both
        default: 'ec2'

env:
  AWS_REGION: us-east-1

jobs:
  switch:
    name: Switch to ${{ inputs.mode }} mode
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get ALB and Target Groups info
      id: alb-info
      run: |
        # Get ALB ARN
        ALB_ARN=$(aws elbv2 describe-load-balancers \
          --region ${{ env.AWS_REGION }} \
          --query "LoadBalancers[?contains(LoadBalancerName, 'tx01-alb-${{ inputs.environment }}')].LoadBalancerArn" \
          --output text)
        echo "alb_arn=$ALB_ARN" >> $GITHUB_OUTPUT
        
        # Get Listener ARN
        LISTENER_ARN=$(aws elbv2 describe-listeners \
          --load-balancer-arn $ALB_ARN \
          --region ${{ env.AWS_REGION }} \
          --query 'Listeners[0].ListenerArn' \
          --output text)
        echo "listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT
        
        # Get EC2 Target Group ARN
        EC2_TG_ARN=$(aws elbv2 describe-target-groups \
          --region ${{ env.AWS_REGION }} \
          --query "TargetGroups[?contains(TargetGroupName, 'tx01-tg-${{ inputs.environment }}')].TargetGroupArn" \
          --output text)
        echo "ec2_tg_arn=$EC2_TG_ARN" >> $GITHUB_OUTPUT
        
        # Try to get EKS Target Group ARN (pode n√£o existir ainda)
        EKS_TG_ARN=$(aws elbv2 describe-target-groups \
          --region ${{ env.AWS_REGION }} \
          --query "TargetGroups[?contains(TargetGroupName, 'k8s-default-tx01serv')].TargetGroupArn" \
          --output text || echo "")
        echo "eks_tg_arn=$EKS_TG_ARN" >> $GITHUB_OUTPUT

    - name: Get EC2 instances
      id: ec2-info
      run: |
        INSTANCE_IDS=$(aws ec2 describe-instances \
          --region ${{ env.AWS_REGION }} \
          --filters "Name=tag:Name,Values=tx01-ec2-${{ inputs.environment }}-*" "Name=instance-state-name,Values=running,stopped" \
          --query 'Reservations[*].Instances[*].InstanceId' \
          --output text)
        echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT

    - name: Install kubectl (for EKS operations)
      if: inputs.mode == 'eks' || inputs.mode == 'both'
      run: |
        curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: Configure mode - EC2 only
      if: inputs.mode == 'ec2'
      run: |
        echo "üîÑ Switching to EC2 mode..."
        
        # Start EC2 instances if stopped
        if [ -n "${{ steps.ec2-info.outputs.instance_ids }}" ]; then
          aws ec2 start-instances \
            --instance-ids ${{ steps.ec2-info.outputs.instance_ids }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for instances to be running..."
          aws ec2 wait instance-running \
            --instance-ids ${{ steps.ec2-info.outputs.instance_ids }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ EC2 instances started"
        fi
        
        # Scale down EKS if exists
        CLUSTER_NAME=$(aws eks list-clusters --region ${{ env.AWS_REGION }} --query "clusters[?contains(@, 'tx01-eks-${{ inputs.environment }}')]" --output text || echo "")
        if [ -n "$CLUSTER_NAME" ]; then
          echo "üìâ Scaling down EKS deployment..."
          aws eks update-kubeconfig --name $CLUSTER_NAME --region ${{ env.AWS_REGION }}
          kubectl scale deployment tx01-app --replicas=0 || true
        fi
        
        # Update ALB listener rules priority (EC2 = higher priority)
        if [ -n "${{ steps.alb-info.outputs.eks_tg_arn }}" ]; then
          echo "üîß Updating ALB listener rules..."
          
          # Get rules
          EC2_RULE=$(aws elbv2 describe-rules \
            --listener-arn ${{ steps.alb-info.outputs.listener_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query "Rules[?Actions[0].TargetGroupArn=='${{ steps.alb-info.outputs.ec2_tg_arn }}'].RuleArn" \
            --output text)
          
          EKS_RULE=$(aws elbv2 describe-rules \
            --listener-arn ${{ steps.alb-info.outputs.listener_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query "Rules[?Actions[0].TargetGroupArn=='${{ steps.alb-info.outputs.eks_tg_arn }}'].RuleArn" \
            --output text)
          
          if [ -n "$EC2_RULE" ] && [ -n "$EKS_RULE" ]; then
            aws elbv2 set-rule-priorities \
              --rule-priorities RuleArn=$EC2_RULE,Priority=50 RuleArn=$EKS_RULE,Priority=100 \
              --region ${{ env.AWS_REGION }}
          fi
        fi
        
        echo "‚úÖ Switched to EC2 mode"

    - name: Configure mode - EKS only
      if: inputs.mode == 'eks'
      run: |
        echo "üîÑ Switching to EKS mode..."
        
        # Get EKS cluster
        CLUSTER_NAME=$(aws eks list-clusters --region ${{ env.AWS_REGION }} --query "clusters[?contains(@, 'tx01-eks-${{ inputs.environment }}')]" --output text)
        
        if [ -z "$CLUSTER_NAME" ]; then
          echo "‚ùå EKS cluster not found. Please provision it first using EKS Deploy workflow."
          exit 1
        fi
        
        # Scale up EKS deployment
        echo "üìà Scaling up EKS deployment..."
        aws eks update-kubeconfig --name $CLUSTER_NAME --region ${{ env.AWS_REGION }}
        kubectl scale deployment tx01-app --replicas=2
        
        echo "‚è≥ Waiting for pods to be ready..."
        kubectl wait --for=condition=ready pod -l app=tx01 --timeout=300s
        
        # Stop EC2 instances
        if [ -n "${{ steps.ec2-info.outputs.instance_ids }}" ]; then
          echo "üõë Stopping EC2 instances..."
          aws ec2 stop-instances \
            --instance-ids ${{ steps.ec2-info.outputs.instance_ids }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ EC2 instances stopped"
        fi
        
        # Update ALB listener rules priority (EKS = higher priority)
        if [ -n "${{ steps.alb-info.outputs.eks_tg_arn }}" ]; then
          echo "üîß Updating ALB listener rules..."
          
          EC2_RULE=$(aws elbv2 describe-rules \
            --listener-arn ${{ steps.alb-info.outputs.listener_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query "Rules[?Actions[0].TargetGroupArn=='${{ steps.alb-info.outputs.ec2_tg_arn }}'].RuleArn" \
            --output text)
          
          EKS_RULE=$(aws elbv2 describe-rules \
            --listener-arn ${{ steps.alb-info.outputs.listener_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query "Rules[?Actions[0].TargetGroupArn=='${{ steps.alb-info.outputs.eks_tg_arn }}'].RuleArn" \
            --output text)
          
          if [ -n "$EC2_RULE" ] && [ -n "$EKS_RULE" ]; then
            aws elbv2 set-rule-priorities \
              --rule-priorities RuleArn=$EKS_RULE,Priority=50 RuleArn=$EC2_RULE,Priority=100 \
              --region ${{ env.AWS_REGION }}
          fi
        fi
        
        echo "‚úÖ Switched to EKS mode"

    - name: Configure mode - Both EC2 and EKS
      if: inputs.mode == 'both'
      run: |
        echo "üîÑ Enabling both EC2 and EKS..."
        
        # Start EC2 instances
        if [ -n "${{ steps.ec2-info.outputs.instance_ids }}" ]; then
          aws ec2 start-instances \
            --instance-ids ${{ steps.ec2-info.outputs.instance_ids }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for instances to be running..."
          aws ec2 wait instance-running \
            --instance-ids ${{ steps.ec2-info.outputs.instance_ids }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ EC2 instances started"
        fi
        
        # Scale up EKS
        CLUSTER_NAME=$(aws eks list-clusters --region ${{ env.AWS_REGION }} --query "clusters[?contains(@, 'tx01-eks-${{ inputs.environment }}')]" --output text || echo "")
        if [ -n "$CLUSTER_NAME" ]; then
          echo "üìà Scaling up EKS deployment..."
          aws eks update-kubeconfig --name $CLUSTER_NAME --region ${{ env.AWS_REGION }}
          kubectl scale deployment tx01-app --replicas=2
          
          echo "‚è≥ Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=tx01 --timeout=300s
        fi
        
        # Set equal priority for both target groups
        if [ -n "${{ steps.alb-info.outputs.eks_tg_arn }}" ]; then
          echo "üîß Setting equal priority for both target groups..."
          
          EC2_RULE=$(aws elbv2 describe-rules \
            --listener-arn ${{ steps.alb-info.outputs.listener_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query "Rules[?Actions[0].TargetGroupArn=='${{ steps.alb-info.outputs.ec2_tg_arn }}'].RuleArn" \
            --output text)
          
          EKS_RULE=$(aws elbv2 describe-rules \
            --listener-arn ${{ steps.alb-info.outputs.listener_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query "Rules[?Actions[0].TargetGroupArn=='${{ steps.alb-info.outputs.eks_tg_arn }}'].RuleArn" \
            --output text)
          
          if [ -n "$EC2_RULE" ] && [ -n "$EKS_RULE" ]; then
            aws elbv2 set-rule-priorities \
              --rule-priorities RuleArn=$EC2_RULE,Priority=50 RuleArn=$EKS_RULE,Priority=50 \
              --region ${{ env.AWS_REGION }}
          fi
        fi
        
        echo "‚úÖ Both EC2 and EKS are now active"

    - name: Verify target health
      run: |
        echo "üè• Checking target health..."
        
        # Check EC2 targets
        echo "EC2 Target Group:"
        aws elbv2 describe-target-health \
          --target-group-arn ${{ steps.alb-info.outputs.ec2_tg_arn }} \
          --region ${{ env.AWS_REGION }} \
          --query 'TargetHealthDescriptions[*].[Target.Id, TargetHealth.State]' \
          --output table
        
        # Check EKS targets if exists
        if [ -n "${{ steps.alb-info.outputs.eks_tg_arn }}" ]; then
          echo ""
          echo "EKS Target Group:"
          aws elbv2 describe-target-health \
            --target-group-arn ${{ steps.alb-info.outputs.eks_tg_arn }} \
            --region ${{ env.AWS_REGION }} \
            --query 'TargetHealthDescriptions[*].[Target.Id, TargetHealth.State]' \
            --output table
        fi

    - name: Get ALB URL
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --region ${{ env.AWS_REGION }} \
          --query "LoadBalancers[?contains(LoadBalancerName, 'tx01-alb-${{ inputs.environment }}')].DNSName" \
          --output text)
        echo ""
        echo "üåê Application URL: http://$ALB_DNS"
        echo ""
        echo "Current mode: ${{ inputs.mode }}"

    - name: Summary
      run: |
        echo "### Switch Environment Summary"
        echo ""
        echo "Environment: ${{ inputs.environment }}"
        echo "Mode: ${{ inputs.mode }}"
        echo ""
        
        case "${{ inputs.mode }}" in
          ec2)
            echo "‚úÖ EC2 instances: Active"
            echo "üí§ EKS cluster: Scaled to 0"
            echo "üí∞ Estimated cost: ~\$50/month"
            ;;
          eks)
            echo "üí§ EC2 instances: Stopped"
            echo "‚úÖ EKS cluster: Active"
            echo "üí∞ Estimated cost: ~\$138/month"
            ;;
          both)
            echo "‚úÖ EC2 instances: Active"
            echo "‚úÖ EKS cluster: Active"
            echo "üí∞ Estimated cost: ~\$188/month"
            ;;
        esac
